---
title: Trees
layout: post
mathjax: true
tags: [algorithm, leetcode]
---
## Bottom Up Recursive VS Top Down Recursive
Most of the tree problems should be resolved by recursive. Sometimes it's confusing whether we should pass parameter in the recursive or we should use the return result of the child in the recursive.

- Top Down recursive: we pass the parameter from the parent to children, so most of time no return value
- Bottom Up recursive: we need to use the result of the subproblem, hence most of time we have return value
## Ancestor Problems
### [235. Lowest Common Ancestor of a Binary Search Tree](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)
Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes p, q in the BST.

Intuition: If p and q are both in the left subtree, we go to the left subtree; If p and q are both in the right subtree, we search the right subtree. Otherwise, the LCA is root itself.
```python
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        if not root:
            return None
        if p.val > root.val and q.val > root.val:
            return self.lowestCommonAncestor(root.right, p, q)
        if p.val < root.val and q.val < root.val:
            return self.lowestCommonAncestor(root.left, p, q)
        return root
```


### [236. Lowest Common Ancestor of a Binary Tree](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/)
Instead of a BST, we are given a binary tree, how to find the LCA for p and q?


## Depth
### [110. Balanced Binary Tree](https://leetcode.com/problems/balanced-binary-tree/)
Given a binary tree, determine if it is height-balanced.

For this problem, a height-balanced binary tree is defined as:

> a binary tree in which the left and right subtrees of every node differ in height by no more than 1.

The simple way is to check from up to bottom:
```python
class Solution:
    def isBalanced(self, root: Optional[TreeNode]) -> bool:
        if not root:
            return True
        return abs(self.depth(root.left) - self.depth(root.right)) <= 1 and self.isBalanced(root.left) and self.isBalanced(root.right)

    def depth(self, root: Optional[TreeNode]) -> int:
        if not root:
            return 0
        return max(self.depth(root.left), self.depth(root.right)) + 1
```
The time complexity is around $O(n\log n)$

The more efficient way is from bottom to up - whenever we find the unbalanced, we will stop the recursion.
```python
class Solution:
    def isBalanced(self, root: Optional[TreeNode]) -> bool:
        return self.dfs(root)[0]
    
    def dfs(self, root: Optional[TreeNode]) -> [bool, int]:
        if not root:
            return [True, 0]
        left, right = self.dfs(root.left), self.dfs(root.right)
        balanced = left[0] and right[0] and abs(left[1] - right[1]) <= 1
        return [balanced, max(left[1], right[1]) + 1 ]
```
- Time complexity : $O(n)$ - For every subtree, we compute its height in constant time as well as compare the height of its children.

## BST
### [530. Minimum Absolute Difference in BST](https://leetcode.com/problems/minimum-absolute-difference-in-bst/)
Given the root of a Binary Search Tree, return the minimum absolute difference between the values of any two different nodes in the tree.

Intuition: The mimimum absolute difference must be the adjacent nodes in **in-order** traversal.


```python
class Solution:
    def geMinimumDiff(self, root: Optional[TreeNode]) -> int:
        self.min_diff = float('inf')
        self.prev = float('-inf')
        self.dfs(root)
        return self.min_diff

    def dfs(self, root: Optional[TreeNode]) -> int:
        if not root:
            return
        self.dfs(root.left)
        # calculate the diff with prev
        self.min_diff = min(min_diff, root.val - prev)
        # change curr as prev val
        self.prev = root.val
        self.dfs(root.right)

```


### [95. Unique Binary Search Trees II](https://leetcode.com/problems/unique-binary-search-trees-ii/)

## Path
### [124. Binary Tree Maximum Path Sum](https://leetcode.com/problems/binary-tree-maximum-path-sum/)


### [129. Sum Root to Leaf Numbers](https://leetcode.com/problems/sum-root-to-leaf-numbers/)

### [113. Path Sum II](https://leetcode.com/problems/path-sum-ii/)

Given the root of a binary tree and an integer targetSum, return all root-to-leaf paths where the sum of the node values in the path equals targetSum. Each path should be returned as a list of the node values, not node references.

For example, targetSum = 22, then the path would be [[5,4,11,2], [5,8,4,5]]
![](/img/leetcode/tree/pathsumii1.jpeg)

Since it's root-to-leaf, we can pass the currSum to children to add, and when we reach the leaf, we check whether currSum equals targetSum, if yes, we add curr path to list. Remember: whenever we go back to the upper level, we should pop up the current val out of the current path.

```python
class Solution:
    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> List[List[int]]:
        def helper(root: Optional[TreeNode], currSum: int, curr: List[int]):
            nonlocal res
            if not root:
                return
            
            curr.append(root.val)
            currSum += root.val

            # left node
            if not root.left and not root.right and currSum == targetSum:
                res.append(curr.copy()) # remember copy here, otherwise the latter change will impact the result
                curr.pop() # go back to upper level, pop out
                return
            
            helper(root.left, currSum, curr)
            helper(root.right, currSum, curr)
            curr.pop()
        
        res = []
        helper(root, 0, [])
        return res

```


### [437. Path Sum III](https://leetcode.com/problems/path-sum-iii/)
Given the root of a binary tree and an integer targetSum, return the number of paths where the sum of the values along the path equals targetSum.

The path does not need to start or end at the root or a leaf, but it must go downwards (i.e., traveling only from parent nodes to child nodes).

![](/img/leetcode/tree/pathsum3-1.jpeg)

#### Method1
The sum of the node to its children is either current node's val plus possible children sums or the current node's val itself.

![](/img/leetcode/tree/pathsum3-2.jpeg)

```python
class Solution:
    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> int:
        def helper(root: Optional[TreeNode]) -> list[int]:
            nonlocal sum_num, targetSum
            if not root:
                return []
            res = [root.val]
            if root.val == targetSum:
                sum_num += 1
            left = helper(root.left)
            right = helper(root.right)

            for sub_sum in left + right:
                if sub_sum + root.val == targetSum:
                    sum_num += 1
                res.append(sub_sum + root.val)
            return res
            
        sum_num = 0
        helper(root)
        return sum_num
```

#### Method2 Prefix Sum
![](/img/leetcode/tree/pathsum3-3.jpeg)

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> int:
        # Since it's up down, we have no return value but pass parameter currsum to the children
        def helper(root: Optional[TreeNode], currSum: int):
            nonlocal sum_num, targetSum
            if not root:
                return
            currSum += root.val
            if currSum == targetSum:
                sum_num += 1
            if currSum - targetSum in dict_t.keys():
                sum_num += dict_t.get(currSum-targetSum)
            dict_t[currSum] = dict_t[currSum] + 1 if currSum in dict_t else 1
            helper(root.left, currSum)
            helper(root.right, currSum)
            dict_t[currSum] -= 1
        
        sum_num = 0
        dict_t = {}
        helper(root, 0)
        return sum_num

```