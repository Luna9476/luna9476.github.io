---
title: Trees
layout: post
mathjax: true
tags: [algorithm, leetcode]
---

## Ancestor Problems

## Depth
### [110. Balanced Binary Tree](https://leetcode.com/problems/balanced-binary-tree/)
Given a binary tree, determine if it is height-balanced.

For this problem, a height-balanced binary tree is defined as:

> a binary tree in which the left and right subtrees of every node differ in height by no more than 1.

The simple way is to check from up to bottom:
```python
class Solution:
    def isBalanced(self, root: Optional[TreeNode]) -> bool:
        if not root:
            return True
        return abs(self.depth(root.left) - self.depth(root.right)) <= 1 and self.isBalanced(root.left) and self.isBalanced(root.right)

    def depth(self, root: Optional[TreeNode]) -> int:
        if not root:
            return 0
        return max(self.depth(root.left), self.depth(root.right)) + 1
```
The time complexity is around $O(n\log n)$

The more efficient way is from bottom to up - whenever we find the unbalanced, we will stop the recursion.
```python
class Solution:
    def isBalanced(self, root: Optional[TreeNode]) -> bool:
        return self.dfs(root)[0]
    
    def dfs(self, root: Optional[TreeNode]) -> [bool, int]:
        if not root:
            return [True, 0]
        left, right = self.dfs(root.left), self.dfs(root.right)
        balanced = left[0] and right[0] and abs(left[1] - right[1]) <= 1
        return [balanced, max(left[1], right[1]) + 1 ]
```
- Time complexity : $O(n)$ - For every subtree, we compute its height in constant time as well as compare the height of its children.

## Counting of Nodes